package com.simon.simontree.model;

import com.simon.simontree.api.TreeElement;
import com.simon.simontree.enums.TypeOfModification;

import java.util.*;

/**
 * Represents a modification group in the tree structure with a list of Modifications {@param childModificationGroups}, unlike a {@link Modification} it does not have a TypeOfModification value.
 * ModificationGroup implement parent-child hierarchy via parentModificationGroup and childModificationGroup. The class is extensible, you can extend it with specialized subclasses.
 * Auto-generated {@param modificationGroupId}.
 * Capable of adding and removing {@link Modification} and child {@link ModificationGroup}.
 * Level is calculated in {@link ModificationBinaryTree}.
 * The class is extensible, you can extend it with specialized subclasses for custom functionality.
 *
 * <p><b>Key extension points:</b>
 *  <ul>
 *     <li>Override {@link #calculateTotalCostOfEveryModificationUnderThisGroup} to implement custom cost calculation logic</li>
 *     <li>Override {@link #calculateTotalPriorityValueOfEveryModificationUnderThisGroup} to implement custom priority  value calculation logic</li>
 *     <li>Override {@link #updateCalculatedValues} to implement custom cost calculation logic</li>
 *   </ul>
 *
 *   <p><b>Example subclass:</b>
 *   <pre>{@code
 *   public class DiscountedModificationGroup extends ModificationGroup{
 *   public DiscountedModificationGroup(Set<Modification> modifications, String name) {
 *   super(modifications, name);
 *   }
 *
 *    @Override
 *    protected long calculateTotalCostOfEveryModificationUnderThisGroup(Set<Modification> modifications) {
 *    return (long) (super.calculateTotalCostOfEveryModificationUnderThisGroup(modifications)*0.9);
 *    }
 *    }
 *   }</pre>
 *
 * <p>Extends the abstract class {@link TreeElement}, which consist of:
 * <ul>
 * <li> protected static AtomicInteger id = new AtomicInteger(0);</li>
 * <li> protected String name;</li>
 * <li> protected int priorityValue;</li>
 * <li> protected long cost</li>
 * <li> protected int level</li>
 * </ul>
 *
 * <p>Null checks:
 * <ul>
 *   <li>nullcheked String {@param name}</li>
 *   <li>nullchecked TypeOfModification {@param typeOfModification}</li>
 * </ul>
 *
 * <p>Key characteristics:
 * <ul>
 *   <li>unique {@param modificationGroupId} (auto-generated)</li>
 *   <li>extends TreeElement, which has id, name, priorityValue</li>
 *   <li>base cost and {@link TypeOfModification} based {@param totalModificationCost}</li>
 *   <li>constructor auto-calculates {@param totalPriorityValueOfAllModifications}, which is the sum of the priority value of all Modifications, which belong to this ModificationGroup</li>
 *   <li>constructor accepts any type of Collection<Modification> for compatibility</li>
 * </ul>
 *
 * @see TreeElement
 * @see ModificationBinaryTree
 * @see Modification
 * @see TypeOfModification
 */
public class ModificationGroup extends TreeElement {
    /**
     * The autogenerated ID, uses the AtomicInteger in TreeElement
     */
    protected final int modificationGroupId;
    /**
     * list of children ModificationGroups, used in establishing parent-child hierarchy
     */
    protected final List<ModificationGroup> childModificationGroups = new ArrayList<>();
    /**
     * simple lock Object for children related methods
     */
    protected final Object childModificationsLock = new Object();
    /**
     * simple lock Object for Set<Modification> related methods
     */
    protected final Object modificationsLock = new Object();
    /**
     * parent of this ModificationGroup, used in establishing parent-child hierarchy
     */
    protected ModificationGroup parentModificationGroup;
    /**
     * parent of this ModificationGroup, used in establishing parent-child hierarchy
     */
    protected Set<Modification> modifications;

    /**
     * Constructs a new ModificationGroup with a set of modifications and a name.
     *
     * @param modifications the set of modifications to be included in this group
     * @param name          the name of the ModificationGroup
     * @throws NullPointerException if either modifications or name is null
     */
    public ModificationGroup(Collection<Modification> modifications, String name) {
        Objects.requireNonNull(name, "Name cannot be null");
        Objects.requireNonNull(modifications, "Modifications cannot be null");
        this.modifications = new HashSet<>();
        this.modificationGroupId = id.incrementAndGet();
        this.priorityValue = calculateTotalPriorityValueOfEveryModificationUnderThisGroup();
        this.name = name;
        this.cost = calculateTotalCostOfEveryModificationUnderThisGroup();
        this.addModifications(modifications);
    }

    /**
     * Adds a child ModificationGroup to this group. Checks circular reference.
     *
     * @param child to add to parent ModificationGroup
     * @return true if the childModificationGroup was added successfully, false otherwise
     * @throws NullPointerException  if childModificationGroup is null
     * @throws IllegalStateException if the childModificationGroup already belongs to another group
     */
    public void addChildModificationGroup(ModificationGroup child) {
        Objects.requireNonNull(child, "Child ModificationGroup cannot be null");

        synchronized (childModificationsLock) {
            if (child == this) {
                throw new IllegalArgumentException("Cannot add self as child");
            }

            if (!childModificationGroups.contains(child)) {
                childModificationGroups.add(child);
                child.setParentModificationGroup(this);
                child.setLevel(this.getLevel() + 1);
            }
        }
    }

    /**
     * Removes a child ModificationGroup from this group.
     *
     * @param childModificationGroup the child ModificationGroup to remove
     * @return true if the child was removed successfully, false otherwise
     * @throws NullPointerException  if childModificationGroup is null
     * @throws IllegalStateException if the childModificationGroup doesn't belong to any group
     */
    public boolean removeChildModificationGroup(ModificationGroup childModificationGroup) {
        Objects.requireNonNull(childModificationGroup, "Child modification group cannot be null");
        boolean remove;
        synchronized (childModificationsLock) {
            if (childModificationGroup.getParentModificationGroup() == null) {
                throw new IllegalStateException("Child was already removed");
            } else {
                remove = this.childModificationGroups.remove(childModificationGroup);
                childModificationGroup.setParentModificationGroup(null);
            }
        }
        return remove;
    }

    /**
     * Adds a Modification to this group.
     *
     * @param modifications the Set of Modifications to add
     * @return true if the Modification was added successfully, false otherwise
     * @throws NullPointerException if Modification is null
     */
    public boolean addModifications(Collection<Modification> modifications) {
        Objects.requireNonNull(modifications, "Modifications cannot be null");
        boolean added;
        synchronized (modificationsLock) {
            added = this.modifications.addAll(modifications);
            if (added) {
                modifications.forEach(mod -> mod.setParent(this));
                updateCalculatedValues();
            }
        }
        return added;
    }

    /**
     * Removes the Modification from this group.
     *
     * @param modification the Modification to remove
     * @return true if the Modification was removed successfully, false otherwise
     * @throws NullPointerException if Modification is null
     */
    public boolean removeModification(Modification modification) {
        Objects.requireNonNull(modification, "Child modification group cannot be null");
        boolean remove;
        synchronized (modificationsLock) {
            remove = modifications.remove(modification);
            if (remove) {
                modification.setParent(null);
                updateCalculatedValues();
            }
        }
        return remove;
    }

    /**
     * Helper method that updates all calculated values for this ModificationGroup but does not propagate the changes
     * to parent ModificationGroup because it is not need.
     * Priority value and total cost are re-calculated.
     */
    protected void updateCalculatedValues() {
        int priorityValue;
        long costOfModifications;

        synchronized (modificationsLock) {
            priorityValue = calculateTotalPriorityValueOfEveryModificationUnderThisGroup();
            costOfModifications = calculateTotalCostOfEveryModificationUnderThisGroup();
        }

        setPriorityValue(priorityValue);
        setCost(costOfModifications);
    }

    /**
     * Calculates the total cost of every Modification attached to this ModificationGroup
     *
     * @return totalCostOfEveryModificationUnderThisGroup is returned, as a long
     * @throws NullPointerException if Set<Modification> is null
     */
    public long calculateTotalCostOfEveryModificationUnderThisGroup() {
        Objects.requireNonNull(modifications, "Modifications should not be null");
        return modifications.stream().mapToLong(m -> m.getTotalModificationCost()).sum();
    }

    /**
     * Calculates the total priority value of every Modification attached to this ModificationGroup
     *
     * @return totalPriorityValueOfEveryModificationUnderThisGroup is returned, as an int
     * @throws NullPointerException if Set<Modification> is null
     */
    protected int calculateTotalPriorityValueOfEveryModificationUnderThisGroup() {
        return modifications.stream().mapToInt(mod -> mod.getPriorityValue()).sum();
    }

    /**
     * Helper method that creates new Node instances, but still properly update node level number, needed so that this class can be extended
     *
     * @param id the id of the Node
     * @param level the level of the ModificationGroup
     * @return Node instance
     */
    protected ModificationBinaryTree.Node createNode(int id, int level) {
        return new ModificationBinaryTree.Node(this, id, this.level);
    }

    /**
     * Returns level number.
     */
    public int getLevel() {
        return level;
    }

    /**
     * Sets level number.
     */
    protected boolean setLevel(int newLevel) {
        if (this.level == newLevel) {
            return false;
        }

        this.level = newLevel;

        synchronized (childModificationsLock) {
            for (ModificationGroup child : childModificationGroups) {
                if (child != this) {
                    child.level = newLevel + 1;
                }
            }
        }
        return true;
    }

    public Long getCost() {
        return cost;
    }

    private void setCost(Long cost) {
        this.cost = cost;
    }

    public String getName() {
        return name;
    }

    public Integer getPriorityValue() {
        return priorityValue;
    }

    private void setPriorityValue(Integer priorityValue) {
        this.priorityValue = priorityValue;
    }

    public Set<Modification> getModifications() {
        return modifications;
    }

    private void setModifications(Set<Modification> modifications) {
        this.modifications = modifications;
    }

    public ModificationGroup getParentModificationGroup() {
        return parentModificationGroup;
    }

    private void setParentModificationGroup(ModificationGroup parentModificationGroup) {
        this.parentModificationGroup = parentModificationGroup;
    }

    public List<ModificationGroup> getChildModificationGroups() {
        return childModificationGroups;
    }

    public int getModificationGroupId() {
        return modificationGroupId;
    }

    public Object getChildModificationsLock() {
        return childModificationsLock;
    }

    public Object getModificationsLock() {
        return modificationsLock;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ModificationGroup that = (ModificationGroup) o;
        return modificationGroupId == that.modificationGroupId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(modificationGroupId);
    }
}